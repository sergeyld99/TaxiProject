Тестовое задание 
Клиент-серверное приложение по заказу такси.
Сервер.

- Обеспечивает подключение и обработку клиентов.
- При подключении клиента ищет ему пару. При невозможности найти пару удерживает соединение.
- Предпочтительной парой будет ближайшая по расстоянию.
- Расстояние измеряется по прямой.
- Координаты задаются двумя параметрами: х и y. Карту можно ограничить разумными пределами.
- Перевозчик может взять в пару пассажира. Пассажир - перевозчика.
- Результат обработки пары - пересылка контактных данных друг другу.
- Возможность работы в многопоточном режиме.

 

Клиент.

- Работа в одном из режимов: перевозчика или пассажира.
- Передает на сервер свою роль (режим), контактные данные и координаты.
- Выводит на экран контактную информацию пары, полученную от сервера.

OS - linux. Язык - Си. Makefile. Краткое описание, как запустить. Исходники будет удобно выложить в git (например на github.com)



Реализация:
Маленько усложнил задачу. Клиент во время сеанса может сообщать информацию об изменении координат.  Типа движущиеся объекты. 
Одновременно передача координат является сигналом "Я живой".
Хотел сделать идентифиацию водителей, но не успел. Псевло-идентификацией является номер сокета.
Настройки сервера не успел вынести в ини-файл, поэтому настройки осуществляются макросами в socket.c

/*Максимальное количество одновременно подключенных клиентов (одинаково для пассажиров и клиентов)*/
#define _STRUCT_POINT_SOCKET_COUNT   500

/*Порт сервера*/
#define _SERVER_PORT    2000

/*Максимальное удаление от точки 0, 0 (радиус удаления)*/
#define   _MAX_RADIUS_DISTANCE  1024

/*Таймаут бездействия клиента в секундах*/
#define     _TIME_OUT_SERVER_SECONDS     10


Компиляция gcc
Сборка Make файла при помощи CMake (cmake <какталог сборки>)
Правило сборки CMakeLists.txt


Для компиляции
make

Исполняемый файл клиента:
m_client
Исполняемый файл сервеа:
m_server


Сервер слушает порт. При получении пакета распознает пассажир или водитель и добавляет его в массив водителей или пассажиров (или меняет координаты у существуюих).
Клиент должен постоянно передавать информцию о себе, иначе по истечении времени бездействия (_TIME_OUT_SERVER_SECONDS) сервер закрывает сокет клиента

Клиент берет свои настройки из параметров запуска 
--type (-t) <p или с> (пассажир или водитель)
--x (-x) <Координата X>
--y (-y) <Координата Y>
--server(-s) <IP адрес сервера> 
--timeout(-o) <Таймаут в миллисикундах (по умолчанию 1000)>
Например
./m_client --type c --server localhost -o 100 -x 10 -y 20


После запускаклиент соединяется с сервером и начинает линейно менять свои координаты в линейном порядке, передавая их на сенрвер с переодичностью [<Таймаут в миллисикундах (по умолчанию 1000)> ]. Если координаты выходят а пределы радиуса досягаемости, клиент отключается от сервера


При подключении клиента, если в массиве подключенных будут клиенты другого типа (для пассажиров водители и наооборот), находится пара с минимальным расстоянием, и обоим шлется сообшене типа "Packet OK Найдена пара 5 x=0, y=-45 расстояние 738.140 i=567 x=566 y=-521". Сокеты пары закрываются, обмен пакетами прекращается, оба клиента зануляются в массивах.
В случае отсутствия пары для клиента координаты начинают линейно менятся на случайный шаг и на экран выводится сообщени типа (Packet OK  i=566 x=565 y=-520). 
В случае ошибки, сервер ее вернет, а клиент выведет на экран.

Тестировал так:
Запускал сервер, запусал 10 клиентов одного типа с интервалом от 10 до 100 мс, затем запусал по одному клиентов другого типа. Вылетов клиентов и сервера не наблюдалось.
Ошибок совместного доступа не возникало.
На утечку памяти не тестировал.


Есть там несколько недоработанных моментов. Так клиент не читает сообщения от сервера пока сам не пошлет туда пакет.
Чтобы все до ума довести еще дней несколько надо.

